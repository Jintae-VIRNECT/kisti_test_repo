<template>
  <nav class="header-lnbs service">
    <ul class="flex">
      <lnb-button
        v-for="menu of menus"
        :key="menu.key"
        :text="menu.text"
        :active="view === menu.key"
        :image="menu.icon"
        :notice="menu.notice"
        @click="goTab(menu.key)"
      ></lnb-button>
    </ul>
  </nav>
</template>

<script>
import { mapGetters, mapActions, mapMutations } from 'vuex'
import {
  SIGNAL,
  DRAWING,
  AR_FEATURE,
  CAPTURE_PERMISSION,
  ROLE,
} from 'configs/remote.config'
import { VIEW } from 'configs/view.config'
import LnbButton from '../tools/LnbButton'
import toastMixin from 'mixins/toast'
import configmMixin from 'mixins/confirm'
// import web_test from 'utils/testing'
export default {
  name: 'HeaderServiceLnb',
  mixins: [toastMixin, configmMixin],
  components: {
    LnbButton,
  },
  data() {
    return {
      drawingNotice: 1,
      arNotice: 2,
      menus: [
        {
          text: this.$t('service.stream'),
          key: VIEW.STREAM,
          icon: require('assets/image/call/gnb_ic_shareframe.svg'),
          notice: false,
        },
        {
          text: this.$t('service.drawing'),
          key: VIEW.DRAWING,
          icon: require('assets/image/call/gnb_ic_creat_basic.svg'),
          notice: false,
        },
        {
          text: this.$t('service.ar'),
          key: VIEW.AR,
          icon: require('assets/image/call/gnb_ic_creat_ar.svg'),
          notice: false,
        },
      ],
    }
  },
  computed: {
    ...mapGetters([
      'mainView',
      'participants',
      'view',
      'shareFile',
      'viewForce',
      'settingInfo',
      'myInfo',
    ]),
    hasLeader() {
      const idx = this.participants.findIndex(
        user => user.roleType === ROLE.LEADER,
      )
      if (idx < 0) return false
      return true
    },
  },
  watch: {
    shareFile(file, oldFile) {
      if (file && file.id && file.id !== oldFile.id) {
        this.addChat({
          name: file.fileName,
          status: 'drawing',
          type: 'system',
        })
        if (this.view !== VIEW.DRAWING) {
          // this.drawingNotice = true
          this.menus[this.drawingNotice].notice = true
        }
      } else if (!file || !file.id) {
        this.menus[this.drawingNotice].notice = false
      }
    },
    hasLeader(val, bVal) {
      if (!val && val !== bVal && this.participants.length > 0) {
        this.toastDefault(this.$t('service.toast_leave_leader'))
        this.showImage({})
        this.setView(VIEW.STREAM)
      }
    },
    mainView: {
      deep: true,
      handler(val, oldVal) {
        // AR 기능 도중 메인뷰 참가자가 나갔을 경우
        if (
          this.view === VIEW.AR &&
          val.id !== oldVal.id &&
          this.account.roleType === ROLE.LEADER
        ) {
          this.$call.sendArFeatureStop()
          this.goTabConfirm(VIEW.STREAM)
        }
      },
    },
  },
  methods: {
    ...mapActions(['setView', 'addChat', 'showImage']),
    ...mapMutations(['updateParticipant']),
    async goTab(type) {
      if (type === this.view) return

      // leader
      if (this.account.roleType === ROLE.LEADER) {
        //현재 view가 AR일때 다른 view를 선택하면 정말 이동할건지 확인 메시지
        if (this.view === VIEW.AR) {
          this.serviceConfirmTitle(
            this.$t('service.ar_exit'),
            this.$t('service.ar_exit_description'),
            {
              text: this.$t('button.exit'),
              action: () => {
                this.$call.sendArFeatureStop()
                this.goTabConfirm(type)
              },
            },
          )
          // this.confirmCancel(this.$t('service.toast_exit_ar'), {
          //   text: this.$t('button.exit'),
          //   action: () => {
          //     this.$call.sendArFeatureStop()
          //     this.goTabConfirm(type)
          //   },
          // })
          return
        }
        if (this.view === VIEW.DRAWING) {
          //현재 view가 DRAWING 일때 다른 view를 선택하면 정말 이동할건지 확인 메시지
          if (this.shareFile && this.shareFile.id) {
            // TODO: MESSAGE
            this.confirmCancel(this.$t('service.toast_exit_drawing'), {
              text: this.$t('button.exit'),
              action: () => {
                this.$call.sendDrawing(DRAWING.END_DRAWING)
                this.goTabConfirm(type)
              },
            })
            return
          }
        }

        if (this.view === VIEW.SCREEN) {
          this.toastDefault(
            this.$t('화면 공유 중에는 다른 메뉴로 이동할 수 없습니다.​'),
          )
          return
        }

        this.goTabConfirm(type)
      } // other user
      else {
        if (this.view === VIEW.AR) {
          this.toastDefault(this.$t('service.toast_cannot_leave_ar'))
          return
        }
        if (this.view === VIEW.SCREEN) {
          this.toastDefault(
            this.$t('화면 공유 중에는 다른 메뉴로 이동할 수 없습니다.​'),
          )
          return
        }

        if (type === VIEW.STREAM) {
          this.setView(VIEW.STREAM)
        }
        if (type === VIEW.SCREEN) {
          await this.getScreenStream()
          this.setView(VIEW.SCREEN)
        }
        if (type === 'drawing') {
          if (this.shareFile && this.shareFile.id) {
            // this.drawingNotice = false
            this.menus[this.drawingNotice].notice = false
            this.setView(VIEW.DRAWING)
          } else {
            this.toastDefault(this.$t('service.toast_cannot_invite_drawing'))
          }
          this.goDrawing()
        }
        if (type === VIEW.AR) {
          if (!this.arNotice) {
            this.toastDefault(this.$t('service.toast_cannot_invite_ar'))
            return
          }
        }
      }
    },
    async goTabConfirm(type) {
      if (type === VIEW.STREAM) {
        this.setView(VIEW.STREAM)
      }
      if (type === VIEW.DRAWING) {
        this.setView(VIEW.DRAWING)
      }
      if (type === VIEW.SCREEN) {
        await this.getScreenStream()
        this.setView(VIEW.SCREEN)
      }
      if (type === VIEW.AR) {
        if (this.viewForce === false) {
          this.toastDefault(this.$t('service.toast_no_sharing'))
          return
        }
        this.permissionCheck()
      }
    },
    goDrawing() {
      if (this.account.roleType === ROLE.LEADER) {
        this.setView(VIEW.DRAWING)
        return
      }
      if (this.shareFile && this.shareFile.id) {
        this.setView(VIEW.DRAWING)
      } else {
        this.toastDefault(this.$t('service.toast_cannot_invite_drawing'))
      }
    },
    permissionSetting(permission) {
      if (permission === true) {
        this.toastDefault(
          this.$t('service.toast_ar_start', { name: this.mainView.nickname }),
        )
        this.addChat({
          status: 'ar-start',
          name: this.mainView.nickname,
          type: 'system',
        })
        this.$call.sendArFeatureStart(this.mainView.id)
        this.setView(VIEW.AR)
      } else if (permission === false) {
        this.toastDefault(this.$t('service.toast_refused_ar'))
        this.addChat({
          status: 'ar-deny',
          type: 'system',
        })
      }
    },
    permissionCheck() {
      // 웹-웹 테스트용
      // if (web_test) {
      //   this.setView('ar')
      //   return
      // }
      if (!this.mainView || !this.mainView.stream) {
        // TODO: MESSAGE
        this.toastDefault(this.$t('service.toast_no_worker'))
        return
      }
      if (this.mainView.id === this.account.uuid) {
        this.toastDefault(this.$t('service.toast_unsupport_ar'))
        return
      }
      if (this.mainView.hasArFeature === false) {
        this.toastDefault(this.$t('service.toast_unsupport_ar'))
        return
      }
      if (this.mainView.permission === false) {
        this.toastDefault(this.$t('service.toast_refused_ar'))
        return
      }
      this.$call.sendCapturePermission([this.mainView.connectionId])
      this.toastDefault(this.$t('service.toast_request_permission'))
    },

    getPermissionCheck(receive) {
      const data = JSON.parse(receive.data)

      // if (data.to !== this.account.uuid) return
      if (data.from === this.account.uuid) return

      if (
        this.account.roleType === ROLE.LEADER &&
        data.type === CAPTURE_PERMISSION.RESPONSE
      ) {
        this.updateParticipant({
          connectionId: receive.from.connectionId,
          permission: data.isAllowed,
        })
        if (this.view !== VIEW.AR) {
          this.permissionSetting(data.isAllowed)
        } else {
          this.$eventBus.$emit('startAr', data.isAllowed)
        }
      }
    },

    checkArFeature(receive) {
      const data = JSON.parse(receive.data)

      if (data.from === this.account.uuid) return
      if (this.account.roleType === ROLE.LEADER) {
        if (data.type === AR_FEATURE.FEATURE) {
          if ('hasArFeature' in data) {
            this.updateParticipant({
              connectionId: receive.from.connectionId,
              hasArFeature: data.hasArFeature,
            })
            if (data.hasArFeature === false) {
              this.addChat({
                status: 'ar-unsupport',
                type: 'system',
              })
            }
          }
        }
      } else {
        if (data.type === AR_FEATURE.START_AR_FEATURE) {
          // TODO: MESSAGE
          this.toastDefault(
            this.$t('service.toast_ar_start', { name: this.mainView.nickname }),
          )
          this.addChat({
            status: 'ar-start',
            name: this.mainView.nickname,
            type: 'system',
          })
          this.setView(VIEW.AR)
        } else if (data.type === AR_FEATURE.STOP_AR_FEATURE) {
          // TODO: MESSAGE
          this.toastDefault(this.$t('service.toast_ar_exit'))
          this.setView(VIEW.STREAM)
        }
      }
    },
    async getScreenStream() {
      //pc자체에서 나오는 소리도 오디오 트랙에 넣어서..? 믹싱해서 보내야할듯?

      if (
        !navigator.mediaDevices ||
        !navigator.mediaDevices['getDisplayMedia']
      ) {
        throw 'NotSupportDisplayError'
      } else {
        const size = this.settingInfo.quality.split('X')
        const video = {
          width: parseInt(size[0]),
          height: parseInt(size[1]),
        }
        //@TODO: 스트림 못가지고오면 빠꾸
        const displayStream = await navigator.mediaDevices.getDisplayMedia({
          audio: true,
          video: video,
        })
        displayStream.getVideoTracks()[0].onended = () => {
          this.$call.restoreMyStream(this.myInfo.video)
          this.setView(VIEW.STREAM)
        }
        this.$call.replaceTrack(
          displayStream.getVideoTracks()[0],
          this.mainView.stream,
        )

        this.$call.sendScreenSharing(true)
      }
      // this.addChat({
      //   //TODO: 협업 공유 대상의 이름이 필요함.
      //   name: '누구누구님',
      //   status: 'screen-sharing',
      //   type: 'system',
      // })
    },
  },

  /* Lifecycles */
  created() {
    this.$call.addListener(SIGNAL.CAPTURE_PERMISSION, this.getPermissionCheck)
    this.$call.addListener(SIGNAL.AR_FEATURE, this.checkArFeature)
    const onlyChromeWithPC = !this.isTablet && !this.isSafari
    if (onlyChromeWithPC)
      this.menus.push({
        text: this.$t('화면 공유'),
        key: VIEW.SCREEN,
        icon: require('assets/image/call/gnb_ic_screen_share.svg'),
        notice: false,
      })
  },
}
</script>
